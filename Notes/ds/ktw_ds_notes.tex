\documentclass[a4paper,chapter,atbegshi]{oblivoir}
\usepackage{fapapersize}
\usefapapersize{210mm,297mm,30mm,*,30mm,32mm}
\usepackage{amsmath, amsfonts, graphicx, xcolor, caption, enumitem, mdframed}
\usepackage{ob-chapstyles, listings,}
\usepackage[longend,ruled,vlined]{algorithm2e}
\hypersetup{colorlinks=true, linkcolor=magenta, citecolor=magenta, urlcolor=cyan,}
\chapterstyle{chappell}
\setlist{nosep}
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{C}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\normalsize\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
\title{자료구조}
\author{김태원}
\date{\today}
\begin{document}
\maketitle
\chapter{\texttt{C} 리뷰}
\begin{mdframed}\textbf{1. }
  입력으로 하나의 양의 정수를 받은 후 $0$이 될 때까지 연속적으로 $2$로 나눈 몫을
  출력하는 프로그램을 작성하라.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
int main(){
  int n;
  scanf("%d", &n);
  for(int i=n; i!=0; i/=2)
    printf("%d ", i);
}
\end{lstlisting}
쉬운 문제다. \colorbox{yellow}{\ttfamily i/=2}는 그냥 멋내는 용이다.
\hfill\break
\begin{mdframed}\textbf{2. }
  입력으로 하나의 양의 정수 $n$을 받은 후 다음의 합을 구하여 출력하는 프로그램을
  작성하라. 단, 소수점 $4$자리까지만 출력하라.
  \[
    1 + \frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}
  \]
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
int main(){
  int n;
  double sum = 0;
  for(double r=1; r<=n; r++)
    sum = sum + 1/r;
  printf("%.4f\n", sum);
}
\end{lstlisting}
5번 라인의 \texttt{for}문에서 \texttt{r}을 \colorbox{yellow}{\ttfamily double}로
선언했다. \texttt{int}로 선언하면 모든 입력에 대해 출력은 1이기 때문이다.
\hfill\break
\begin{mdframed}\textbf{3. }
  입력으로 하나의 양의 정수 $n$을 받은 후 다음의 합을 구하여 출력하는 프로그램을
  작성하라. 단, 소수점 4자리까지만 출력하라.
  \[
    1+\frac{1}{2!}+\frac{1}{3!}+\cdots+\frac{1}{n!}
  \]
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
int main(){
  int n;
  double sum = 0;
  scanf("%d", &n);
  for(double i=1; i<=n; i++){
    double frac = 1;
    for(double j=i; j>0; j--)
      frac *= j;
    sum += 1/frac;
  }
  printf("%.4f\n", sum);
}
\end{lstlisting}
순서대로 해결했다. 9번 라인이 아니라 7번 라인에서 \texttt{frac}을 선언한
이유는 10번 라인에서 \texttt{frac}이 쓰이기 때문이다.
\hfill\break
\begin{mdframed}\textbf{4. }
  먼저 입력될 정수의 개수 $n\leq100$을 입력받고, 이어서 $n$개의 정수를 받아
  평균과 표준편차를 계산하여 소수점 이하 4번째 자리까지 출력하는 프로그램을
  작성하라. 표준편차는 다음과 같이 정의된다. 루트를 계산하기 위해서 
  \texttt{math.h}를 \texttt{include}하고 \texttt{sqrt}함수를 사용하라.
  \[
    SD = \sqrt{\frac{1}{N}\sum_{i=1}^N(x_i-\bar{x})^2}
  \]
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int main(){
  int n;
  int *arr;
  double avg = 0;
  double sum = 0;
  scanf("%d", &n);
  arr = (int *)malloc(sizeof(int)*n);
  for(int i=0; i<n; i++){
    int p;
    scanf("%d", &p);
    arr[i] = p;
    avg += arr[i];
  }
  for(int i=0; i<n; i++)
    sum += pow(arr[i]-avg/n, 2.0);
  printf("%.5g\n", sqrt(sum/n));
  free(arr);
}
\end{lstlisting}
\colorbox{yellow}{\ttfamily .5g}라는 formant specifier를
사용했는데, 가령 $4.5000\ldots$를 $4.5$로 잘라서 출력하기 위해서다. 참고로
\texttt{math.h} 라이브러리를 포함한 파일을 컴파일하려면 \texttt{-lm} 명령어를
덧붙여야 한다.
\hfill\break
\begin{mdframed}\textbf{5. }
  먼저 입력될 정수의 개수 $2\leq n\leq 100$을 입력받고, 이어서 $n$개의 정수를
  입력받는다. 입력된 정수들 중에서 최소값과 두 번째로 작은 값을 찾아
  출력하는 프로그램을 작성하라. 만약 최소값이 2개 이상 중복되어 존재하면
  그 중 하나를 최소값으로, 다른 하나를 두 번째로 작은 값으로 간주한다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
int main(){
  int n, key;
  int *arr;
  scanf("%d", &n);
  arr = (int*)malloc(sizeof(int)*n);
  for(int i=0; i<n; i++)
    scanf("%d", &arr[i]);
  for(int i=1; i<n; i++){
    key = arr[i];
    int j;
    for(j=i-1; j>=0 && arr[j]>key; j--)
      arr[j+1] = arr[j];
    arr[j+1] = key;
  }
  printf("%d %d\n", arr[0], arr[1]);
  free(arr);
}
\end{lstlisting}
10번 라인에서 시작되는 \texttt{for} 블록은 삽입정렬 알고리즘을 구현한 것이다.
\begin{algorithm}
  \caption{Insertion Sort}
  \KwIn{$A$: Array}
  \For{$i\in\lbrace2,\ldots, A.length\rbrace$}{
    $key \gets A[i]$\\
    $j\gets i-1$ \\
    \While{$j>0\;\&\; A[j]>key$}{
      $A[j+1]\gets A[j]$ \\
      $j\gets j-1$ 
    }
    $A[j+1]\gets key$
  }
\end{algorithm}
삽입 정렬 알고리즘은 아래와 같은 방식으로 작동한다.
\begin{align*}
  A =
  [7,3,1,2,4,6]\quad &\textrm{ 첫 번째 for 루프: }7=A[1]>key=A[2]=3 \\ 
                &\mapsto [3,7,1,2,4,6]\\
                & \textrm{ 두 번째 for 루프: }7=A[2]>key=A[3]=1\\
                &\mapsto [3,1,7,2,4,6] \\
                & \textrm{ 두 번째 for 루프: }3=A[1]>key=A[3]=1 \\
                &\mapsto [1,3,7,2,4,6] \\
                &\textrm{ 세 번째 for 루프: }7=A[3]>key=A[4]=2\\
                &\mapsto [1,3,2,7,4,6] \\
                &\textrm{ 세 번째 for 루프: }3=A[2]>key=A[4]=2\\
                &\mapsto [1,2,3,7,4,6] \\
                &\textrm{ 네 번째 for 루프: }7=A[4]>key=A[5]=4\\
                &\mapsto [1,2,3,4,7,6]\\
                &\textrm{ 다섯 번째 for 루프: }7=A[5]>key=A[6]=6\\
                &\mapsto [1,2,3,4,6,7]
\end{align*}
\begin{mdframed}\textbf{6. }
  수열에서 큰 값이 작은 값보다 앞서 나오는 경우 두 값을 역전된 쌍이라고 부른다.
  예를 들어 수열 $4,2,1,1,3$에는 $(4,2),(4,1),(4,1),(4,3),(2,1),(2,1)$의 총
  6개의 역전된 쌍이 있다. 수열을 입력으로 받아서 역전된 쌍의 개수를 카운트하여
  출력하는 프로그램을 작성하라. 키보드로부터 먼저 정수의 개수 $N$을 입력받고,
  이어서 $N$개의 정수를 입력 받는다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
int main(){
  int n, gncount;
  int* arr;
  scanf("%d", &n);
  arr = (int*)malloc(sizeof(int)*n);
  for(int i=0; i<n; i++)
    scanf("%d", &arr[i]);
  for(int i=0; i<n; i++){
    int gn = arr[i];
    for(int j=i; j<n; j++){
      if(gn > arr[j])
        gncount++;
    }
  }
  free(arr);
  printf("%d\n", gncount);
}
\end{lstlisting}
\texttt{for}문을 돌면서 각 성분에 대해 그 성분보다 큰 것들을 세는 단순무식한
코드다.
\hfill\break
\begin{mdframed}\textbf{7. }
  키보드로부터 연속해서 음이 아닌 정수들을 입력받는다. 정수가 하나씩 입력될
  때마다 현재까지 입력된 정수들을 오름차순으로 정렬하여 화면에 출력한다. 단,
  새로 입력된 정수가 이미 이전에 입력된 정수라면 \texttt{duplicate}라고 출력하고
  저장하지 않고 버린다. 사용자가 $-1$을 입력하면 프로그램을 종료한다. 입력되는
  정수의 개수는 100개를 넘지 않는다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
int check(int* arr, int size, int n);
void insertionSort(int* arr, int size);
int main(){
  int arr[100];
  scanf("%d", &arr[0]);
  printf("%d\n\n", arr[0]);
  for(int i=1; i<100; i++){
    int n;
    scanf("%d", &n);
    if(n==-1)
      break;
    if(check(arr, i, n)){
      arr[i] = n;
      insertionSort(arr, i);
      for(int j=0; j<=i; j++)
        printf("%d ", arr[j]);
    }
    else{
      i--;
      printf("duplicate");
    }
    printf("\n\n");
  }
}
int check(int* arr, int size, int n){
  int result;
  for(int i=0; i<size; i++){
    if(arr[i]==n){
      result = 0;
      break;
    }
    else
      result = 1;
  }
  return result;
}
void insertionSort(int* arr, int size){
  for(int i=1; i<=size; i++){
    int key = arr[i];
    int j;
    for(j=i-1; j>=0 && arr[j]>key; j--)
      arr[j+1] = arr[j];
    arr[j+1] = key
  }
}
\end{lstlisting}
\hfill\break
\begin{mdframed}\textbf{8. }
  먼저 입력될 정수의 개수 $n\leq 100$을 입력받고, 이어서 $n$개의 정수를 받아
  순서대로 배열에 저장한다. 그런 다음 키보드로부터 다시 하나의 정수 $k$를
  입력받은 후 $n$개의 정수들 중에서 $k$에 가장 가까운, 즉 $k$와의 차이의
  절대값이 가장 작은 정수를 찾아 출력하는 프로그램을 작성하라. 
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
int main(){
  int n, k, diff;
  int* arr;
  scanf("%d", &n);
  arr = (int*)malloc(sizeof(int)*n);
  for(int i=0; i<n; i++)
    scanf("%d", &arr[i]);
  scanf("%d", &k);
  diff = arr[0];
  for(int i=0; i<n; i++){
    if(abs(k-diff) > abs(k-arr[i]))
      diff = arr[i];
  }
  free(arr);
  printf("%d\n", diff);
}
\end{lstlisting}
\colorbox{yellow}{\ttfamily abs} 함수를 사용한 단순무식한 방법이다.
\hfill\break
\begin{mdframed}\textbf{9. }
  사용자로부터 $n<100$개의 정수를 입력받아 크기순으로 정렬한 후 중복된 수를
  제거하는 프로그램을 작성하라. 입력 형식은 먼저 $n$의 값이 주어지고 이어서
  $n$개의 정수들이 주어진다. 예를 들어 $n=8$이고 입력된 정수들이 $4,7,4,12,4
  10,9,7$이라면 중복을 제거하고 남은 정수들은 $4,7,9,10,12$이다. 그러면 먼저
  남은 정수의 개수 $5$를 출력하고 콜론을 출력한 후 남은 정수들을 오름차순으로
  출력한다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
void insertionSort(int* arr, int size);
int main(){
  int n;
  int count = 0;
  int index = 0;
  int *temp, *arr;
  scanf("%d", &n);
  temp = (int*)malloc(sizeof(int)*n); 
  arr = (int*)malloc(sizeof(int)*count);
  for(int i=0; i<n; i++)
    scanf("%d", &temp[i]);
  for(int i=0; i<n; i++){
    int check = 0;
    for(int j=0; j<i; j++){
      if(temp[i]==temp[j]){
        check = 1;
        break;
      }
    }
    if(check == 0){
      count++;
      arr[index] = temp[i];
      index++;
    }
  }
  free(temp);
  insertionSort(arr, count);
  printf("%d: ", count);
  for(int i=0; i<count; i++)
    printf("%d ", arr[i]);
  printf("\n");
  free(arr);
}
void insertionSort(int* arr, int size){
  for(int i=1; i<size; i++){
    int key = arr[i];
    int j;
    for(j=i-1; j>=0 && arr[j]>key; j--)
      arr[j+1] = arr[j];
    arr[j+1] = key;
  }
}
\end{lstlisting}
다양한 불변항을 사용했다.
\hfill\break
\begin{mdframed}\textbf{10. }
  정렬을 하는 가장 간단한 방법 중의 하나는 다음과 같이 하는 것이다. 배열
  \texttt{data}에 \texttt{data[0]}에서 \texttt{data[n-1]}까지 $n$개의 정수가
  저장되어 있다. 먼저 \texttt{data[0]}와 \texttt{data[n-1]} 사이의 정수들
  중에서 가장 큰 정수를 찾는다. 그것을 \texttt{data[k]}라고 가정해보자.
  그러면 \texttt{data[k]}와 \texttt{data[n-1]}을 교환한다. 이제 가장 큰
  정수가 \texttt{data[n-1]}, 즉 맨 마지막 위치에 저장되었으므로 그 값에 대해서는
  더 이상 생각할 필요가 없다. 이제 \texttt{data[0] - data[n-2]} 중에서 최대값을
  찾는다. 그 값을 \texttt{data[p]}라고 하자. 그러면 다시 \texttt{data[p]}와
  \texttt{data[n-2]}를 교환하고 \texttt{data[n-2]}에 대해서는 잊어버려도 된다.
  이런 식으로 계속하면 마지막에는 \texttt{data[0]}과 \texttt{data[1]} 중에
  최대값을 \texttt{data[1]}과 교환하면 전체의 정렬이 완료된다. 이 알고리즘을
  구현하라. 입력은 먼저 정렬할 개수 $n\leq 100$이 주어지고 이어서 $n$개의
  정수들이 주어진다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
void selectionSort(int* arr, int size);
void swap(int* a, int* b);
int main(){
  int n;
  int* data;
  scanf("%d", &n);
  data = (int*)malloc(sizeof(int)*n);
  for(int i=0; i<n; i++)
    scanf("%d", &data[i]);
  selectionSort(data, n);
  for(int i=0; i<n; i++)
    printf("%d ", data[i]);
  printf("\n");
  free(data);
}
void selectionSort(int* arr, int size){
  int i, j, max;
  for(i=size-1; i>0; i--){
    max = i;
    for(j=i-1; j>=0; j--)
      if(arr[j] > arr[max])
        max=j;
      swap(&arr[max], &arr[i]);
  }
}
void swap(int* a, int* b){
  int temp = *a;
  *a = *b;
  *b = temp;
}
\end{lstlisting}
선택정렬 알고리즘에 대한 문제다. 배열 성분 자체를 최대값으로 두지 않고
최대값의 성분에 대응하는 인덱스로 정렬한다는 점에 유의하라. 보통 선택
정렬은 최대값이 아니라 최소값을 기준으로 한다. 불변항만 살짝 바꾸면 된다.
\begin{algorithm}
  \caption{Selection Sort}
  \KwIn{$A$: Array}
  \For{$i\in\lbrace1,\ldots, A.length-1\rbrace$}{
    $min \gets i$\\
    \For{$j\in\lbrace i+1, A.length-1$}{
      \If{$A[j]<A[min]$}{
        $min\gets j$
      }
    }
  \If{$min\neq i$}{
    swap($A[i],A[min]$)
    }
  }
\end{algorithm}
\begin{mdframed}\textbf{11. }
  입력으로 하나의 문자열을 받은 후 뒤집어서 출력하는 프로그램을 작성하라. 예를
  들어 \texttt{hello}를 입력하면 \texttt{olleh}가 출력된다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <string.h>
void revstr(char *str);
int main(){
  char* str;
  scanf("%s", str);
  revstr(str);
  printf("%s\n", str);
  return 0;
}
void revstr(char *str){
  int len = strlen(str);
  for(int i=0; i<len/2; i++){
    int temp = str[i];
    str[i] = str[len-i-1];
    str[len-i-1] = temp;
  }
}
\end{lstlisting}
단순하게 swap하여 해결했다.
\hfill\break
\begin{mdframed}\textbf{12. }
  영문 소문자로 구성된 하나의 문자열을 입력받은 후 문자열을 구성하는 문자들을
  알파벳 순으로 정렬하여 만들어지는 문자열을 출력하라. 예를 들어 \texttt{hello}가
  입력되면 \texttt{ehllo}를 출력한다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <string.h>
void alphabetOrder();
int main(){
  char *ch;
  scanf("%s", ch);
  alphabetOrder(ch);
  puts(ch);
}
void alphabetOrder(char *ch){
  char temp;
  int i, j, length = strlen(ch);
  for(i=0; i<length; i++){
    for(j=i+1; j<length; j++){
      if(ch[i] > ch[j]){
        temp = ch[i];
        ch[i] = ch[j];
        ch[j] = temp;
      }
    }
  }
}
\end{lstlisting}
기본적으로 선택정렬 알고리즘의 응용이다.
\hfill\break
\begin{mdframed}\textbf{13. }
  아나그램이란 문자들의 순서를 재배열하여 동일하게 만들 수 있는 문자열을
  말한다. 대소문자는 구분하지 않는다. 예를 들어서 \texttt{Silent}와
  \texttt{Listen}은 아나그램이다. 입력으로 두 문자열을 받아서 아나그램인지
  판단하는 프로그램을 작성하라.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <string.h>
void cnvt_lwr(char *str);
int anagram(char *str1, char *str2);
int main(){
  char *words[2];
  for(int i=0; i<2; i++){
    char buf[100];
    scanf("%s", buf);
    words[i] = strdup(buf);
    cnvt_lwr(words[i]);
  }
  if(anagram(words[0], words[1]))
    puts("yes");
  else
    puts("no");
}
void cnvt_lwr(char *str){
  for(int i=0; i<strlen(str); i++){
    if(str[i] >= 65 && str[i] <= 90)
      str[i] = str[i]+32;
  }
}
int anagram(char *str1, char *str2){
  if(strlen(str1)!=strlen(str2))
    return 0;
  int count = 0;
  for(int i=0; i<strlen(str1); i++){
    for(int j=0; j<strlen(str1); j++){
      if(str1[i]==str2[j]){
        count++;
        break;
      }
    }
  }
  if(count==check)
    return 1;
  else
    return 0;
}
\end{lstlisting}
\texttt{main}에서 중요한 것은 \colorbox{yellow}{\texttt{buf}와 \texttt{strdup}을
이용한 입력}이다. \texttt{anagram}은 단순무식한 논리를 \texttt{break}로
구현한 것이고 \texttt{cnvt\_lwr}는 ASCII 값을 활용하는 함수이므로
그냥 외워두는 편이 나을 것 같다.
\begin{mdframed}\textbf{14. }
  영문 소문자로 구성된 2개의 단어를 입력받은 후 두 단어가 동일한 문자집합으로
  구성되었는지 검사하여 \texttt{yes} 혹은 \texttt{no}를 출력하는 프로그램을
  작성하라. 예를 들어 \texttt{ababc}와 \texttt{cba}는 문자집합 
  \texttt{\{a,b,c\}}로 구성되었으므로 \texttt{yes}다. 입력 단어의 길이는 20이하다.
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <string.h>
int alphSet(int* wordA, int* wordB);
int main(){
  char* words[2];
  char alphabet[26];
  int firstAlphCount[26], secAlphCount[26];
  for(int i=0; i<2; i++){
    char buf[20];
    scanf("%s", buf);
    words[i] = strdup(buf);
  }
  for(int i=0; i<26; i++){
    alphabet[i] = 'a'+i;
    firstAlphCount[i] = 0;
    secAlphCount[i] = 0;
  }
  for(int i=0;i<strlen(words[0]);i++){
    for(int j=0;j<26;j++){
      if(words[0][i] == alphabet[j])
        firstAlphCount[i] = 1;
    }
  }
  for(int i=0;i<strlen(words[1]);i++){
    for(int j=0;j<26;j++){
      if(words[1][i] == alphabet[j])
        secAlphCount[i] = 1;
    }
  }
  if(alphSet(firstAlphCount, secAlphCount))
    puts("yes");
  else
    puts("no");
}
int alphSet(int* wordA, int* wordB){
  for(int i=0; i<26; i++){
    if(wordsA[i] != wordsB[i])
      return 0;
  }
  return 1;
}
\end{lstlisting}
단순무식하지만 뭘 하려는지 잘 보인다. 아무튼 14번 라인인
\colorbox{yellow}{\texttt{alphabet[i] = 'a'+i}}가 핵심이다.
\hfill\break
\begin{mdframed}\textbf{15. }
  입력으로 $n<100$개의 영문 문자열을 받는다. 각 문자열의 길이는 20이하다. 이
  문자열들을 문자열의 길이가 짧은 것부터 긴 것 순서로 정렬하여 출력하라. 단,
  길이가 동일한 문자열들은 그들끼리 사전식 순서로 정렬해야 한다. 입력 형식은
  먼저 문자열의 개수 $n$이 주어지고, 이어서 $n$개의 문자열이 한 줄에 하나씩
  주어진다. 
\end{mdframed}
\begin{lstlisting}[style=C]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(){
  int n;
  char **words;
  scanf("%d", &n);
  words = (char **)malloc(sizeof(char[101])*n);
  for(int i=0; i<n; i++){
    char buf[101];
    scanf("%s", buf);
    words[i] = strdup(buf);
  }
  for(int i=0; i<n; i++){
    for(int j=0; j<n; j++){
      if(strlen(words[j])>strlen(words[i])){
        char* temp1;
        temp1 = words[i];
        words[i] = words[j];
        words[j] = temp1;
      }
      else if(strlen(words[j])==strlen(words[i])){
        if(words[j][0] > words[i][0]){
          char* temp2;
          temp2 = words[i];
          words[i] = words[j];
          words[j] = temp2;
        }
      }
    }
  }
  printf("\n");
  for(int i=0; i<n; i++)
    printf("%s\n", words[i]);
  free(words);
}
\end{lstlisting}
8번 라인의 동적 할당에서 쓰인 이중 포인터를 이해하는 것이 관건이다. 다시 말해
14번 라인 이하의 \texttt{for} 블록에서 swap되는 \texttt{words[]}는 문자가 아니라
문자열 자체다.
\end{document}
